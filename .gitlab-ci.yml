workflow:
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH

stages:
  - pre-check
  - test
  - build
  - deploy

lint:
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:golangci-lint-alpine
  stage: test
  script:
    # Use default .golangci.yml file from the image if one is not present in the project root.
    - '[ -e .golangci.yml ] || cp /golangci/.golangci.yml .'
    # Write the code coverage report to gl-code-quality-report.json
    # and print linting issues to stdout in the format: path/to/file:line description
    # remove `--issues-exit-code 0` or set to non-zero to fail the job if linting issues are detected
    - golangci-lint run --issues-exit-code 0 --print-issued-lines=false --out-format code-climate:gl-code-quality-report.json,line-number
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json

format:
  image: golang:latest
  stage: test
  script:
    - make test

docker-build:
  # Use the official docker image.
  image: docker:cli
  stage: build
  services:
    - docker:dind
  variables:
    DOCKER_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  # All branches are tagged with $DOCKER_IMAGE_NAME (defaults to commit ref slug)
  # Default branch is also tagged with `latest`
  script:
    - cp deploy/Dockerfile .
    - docker build --pull -t "$DOCKER_IMAGE_NAME" .
    - docker push "$DOCKER_IMAGE_NAME"
    - |
      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
        docker tag "$DOCKER_IMAGE_NAME" "$CI_REGISTRY_IMAGE:latest"
        docker push "$CI_REGISTRY_IMAGE:latest"
      fi
  # Run this job in a branch where a Dockerfile exists
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - deploy/Dockerfile

deploy:
    stage: deploy
    image: alpine:latest
    script:
        - apk add --no-cache openssh-client
        - mkdir -p ~/.ssh
        - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
        - chmod 600 ~/.ssh/id_rsa
        - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY"
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG && docker-compose -f docker-compose.yml up -d"
        - scp -i ~/.ssh/id_rsa docker-compose.yml $DEPLOY_USER@$DEPLOY_SERVER:/home/ubuntu
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker-compose -f docker-compose.yml down"
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker-compose -f docker-compose.yml up -d"
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker-compose -f docker-compose.yml ps"
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker-compose -f docker-compose.yml logs"
        - ssh -i ~/.ssh/id_rsa $DEPLOY_USER@$DEPLOY_SERVER "sudo docker-compose -f docker-compose.yml exec favsapi ./favsapi"
    rules:
        - if: $CI_COMMIT_TAG
        - if: $CI_COMMIT_BRANCH
